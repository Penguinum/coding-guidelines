Конфигурация
============

На всех девелоперских машинах обязательно иметь настроенными

    git config --global user.name "User Name"
    git config --global user.email "user@example.com"

У каждого коммиттера должна быть своя уникальная пара user.name / user.email,
чтобы знать, кого бить по рукам в случае чего. Коммиттеры не должны использовать
больше одной такой пары, чтобы не портить статистику.

Рекомендуется также настроить (по вкусу)

    git config --global rerere.enabled true
    git config --global color.diff auto
    git config --global color.interactive auto
    git config --global color.status auto

Ставим git-email для отправки готовых фичей на ревью лидам проекта

    sudo apt-get install git-email

Правим конфиг send-email на отсылку патчей (используем gmail'овский smtp сервер)

    git config --global sendemail.smtpserver smtp.gmail.com
    git config --global sendemail.smtpserverport 587
    git config --global sendemail.smtpencryption tls
    git config --global sendemail.smtpuser your_email@gmail.com
    git config --global sendemail.smtppass your_password
    git config --global sendemail.assume8bitEncoding = utf-8

Для правильной нумерации патчей в патчсетах, отправляемых на ревью, делаем:

    git config --global format.numbered true

Коммиты
=======

1. Коммитим помельче — атомарными смысловыми кусками. Пользуемся возможностью
закоммитить часть файла (hunk). (Но без фанатизма — если сильно долго разбирать
лапшу, можно в качестве исключения закоммитить всё сразу.)

2. Сообщения о коммитах — на английском (можно на ломанном). Кириллицу иногда
тяжело просматривать в консоли на сервере.

3. Первая строка в сообщении о коммите — краткое описание того, что случилось (до
50-ти символов, не строго).

4. Если нужно детальное описание — оно идёт с отбивкой пустой строкой. Стандартные
гитовые тулзы заточены на такой формат.

5. В одном коммите не должно быть смешения рукописного и генерированного кода.

Ветки
=====

Делаем push на сервер почаще. Приятно видеть хотя бы один пуш в день.

Ветку master не трогаем ни при каких обстоятельствах — её трогает только
maintainer.

Все остальные не "системные" ветки называем с префиксом:
`<developer-initials>/<branch-name>` (`ag/mybranch`, `ik/otherbranch`)

Ветки, относящиеся к тикетам (фичебранчи), должны после инциалов содержать номер
тикета: `/ag/555/short_summary`.

Ветки, на повторном ревью должны содержать номер итерации:
`/ag/555/short_summary/v2` (см. раздел _Ревью кода_). При блокирующих ревью меняем
историю ветки, а не досылаем патчи.

Плодим свои ветки как удобно. Рекомендую подход с feature (aka topic) branches —
по ветке на фичу.

Новые ветки начинаем от `master` для библиотечных проектов и от `dev` для остальных
(а еще лучше предварительно уточнить у майнтейнера откуда начинать).

Если майнтейнер тормозит с обновлением мастера, вполне допускается начать ветку
от невлитой ветки с нужными фичами (майнтейнеру при этом нужно выписать пинка,
чтобы не тормозил).

Регулярно перематываем (`git rebase`) ветки, находящиеся в работе, к мастеру, чтобы
облегчить слияние в конце разработки. В идеале — перематываем каждый раз когда
мастер изменяется.

Когда работа над веткой завершена, делаем ей `git rebase master`, тестируем и даём
мейнтейнеру отмашку на вливание ветки в мастер. Влитые в мастер ветки стираем
(либо ресетим к мастеру, если очень хочется сохранить).

(Для прикладных /не библиотечных/ проектов.) На каждую инсталляцию есть по ветке
(обычно называются по имени хоста, без префикса), голова которой указывает на
тот код, который сейчас вылит на эту инсталляцию. Эти ветки контролирует и
обновляет тот, кто производит выливку на соответствующие инсталляции (может быть
несколько человек, если это, например, инсталляция для первичного тестирования).

Во многих проектах есть директория lib, в которой живут зависимости. Некоторые 
из этоих зависимостей могут быть притянуты как `git subtree`. *Коммититься в них
из репозитория проекта нельзя ни в коем случае.* Нужно сделать коммит в основной
репозиторий, запушиться и притянуть правки (обычно через `bin/update-subtrees
update`).

В зависимости от проекта и библиотеки могут быть шорткаты для тестирования —
спрашивайте лидов :)

Ревью кода
==========

После завершение работы над тикетом соответствующая ветка посылается в виде
patch series на ревью кода лидом проекта.

Проекты на гитхабе (lua-nucleo, lua-aplicado...) мы ревьюим на общих основаниях,
через почту.

В lua-nucleo, lua-aplicado ВСЕ ревью — БЛОКИРУЮЩИЕ.

##Git & e-mail

###Формируем patch'и

    git format-patch -n --cover-letter master

С указанием каталога, куда положить файлы:

    git format-patch -n --cover-letter -o ~/projects/review master

Патч должен быть для той ветки, от которой растет ветка с правками, т.е. для
некоторых проектов это будет не `master`, а `dev` (см. раздел _Ветки_)

    git format-patch -n --cover-letter -o ~/projects/review dev

###Редактируем patch

Открываем файл `0000-cover-letter.patch` на редактирование:

1. Правим 4-ю строчку Subject:
   `[PATCH 0/3] *** SUBJECT HERE ***` таким образом, чтобы получилось следующее:
   `[PATCH 0/3] changes_short_sumary | project_name | ag/555/branch_name`

2. Ниже (вместо `*** BLURB HERE ***`) добавляем *ссылку на соответствующий тикет*
   и краткое описание что и как было сделано по задаче.
   Для повторного ревью также - что было исправлено/переделано.

3. Во всех остальных файлах вида `0001-commit-message.patch` дополняем Subject:
   `[PATCH 1/3] commit message` до
   `[PATCH 1/3] commit message | project_name | ag/555/branch_name`

###Отправляем на ревью

    git send-email --to 'logiceditor-com-review@googlegroups.com' *.patch
    
*Внимание!* Максимальный размер письма в 4Мб. Будьте аккуратны и не отсылайте
графические ресурсы в бинарном коде на ревью!

##Redmine

Алгоритм работы с тикетом:

1. Написать, что отправлено на ревью.

2. Установить соответствущий статус (*On Blocking/Nonblocking Review*) и передать
тикет ревьюеру.

Ревьюер должен отметиться и в тикете и в треде с ревью (в одном из мест можно
написать только результат: принято/не принято,  дублировать в оба места
не нужно) и вернуть тикет автору со статусом *Review Feedback*.

##GitHub

Алгоритм работы с ветками и issues на гитхабе

(Только для тех наших проектах, с открытым исходным которые мы  держим там,
читай lua-nucleo, lua-aplicado и те "не наши" в которые мы активно контибутим
— lua-posix, luarocks etc.) 

1. Заводим тикет в "внутреннем" редмайне

2. Заводим парный ему тикет в issues гитхаба, на английском.
   Указываем там номер тикета из пункта 1 в виде #NNN без указания трекера.

3. Идем в корпоративный редмайн и добавляем в тикет ссылку на issue в гитхабе.

